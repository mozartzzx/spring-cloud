#Histrix 断路器容错机制
#主要作用： 服务熔断，服务降级，请求缓存，请求合并，服务监控，线程和信号隔离；
# 	发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，
#避免了服务雪崩的问题

#服务雪崩的问题描述：所有的请求都在处理一个服务，造成其他服务不能访问
#如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪
#在微服务架构里，一个系统会有很多的服务。这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂
以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。
现在假设订单服务自己最多只有 100 个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。
咱们一起来分析一下，这样会导致什么问题?如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的 100 个线程都会卡在请求积分服务这块，导致订单服务没有一个线程可以处理请求。
然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了。
#这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。
比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。

#所以这个时候就要进行熔断
# 服务降级
不可用服务的调用快速失败 一般通过 超时机制,  降级方法 来实现
# 服务熔断（断路器打开）
1、整个链路达到一定的阀值，默认情况下，10秒内产生超过20次请求，则符合第一个条件。
2、满足第一个条件的情况下，如果请求的错误百分比大于阀值，则会打开断路器，默认为50%。
3、先满足第一个条件，再满足第二个条件，熔断器就进入打开状态。这个状态下我们所有针对该服务的请求
（以依赖隔离的线程池为隔断单位，同一线程池中的所有hiystrix command都会被熔断）都会默认使用降级策略进行处理而不会访问服务。这段时间我们称作“休眠期”
4、一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复
# 服务降级 
服务降级基本理解：当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作
Histrix的超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。
实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值。
# 线程和信号隔离
限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用
比如：Hystrix 会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务
打个比方：现在很不幸，积分服务挂了，会咋样?当然会导致订单服务里那个用来调用积分服务的线程都卡死不能工作了啊!
但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响


# 请求缓存
#请求缓存是在同一请求多次访问中保证只调用一次这个接口中的内容(如果是基于注解实现的话，这个接口就会被CacheResult修饰的，里面是访问去服务提供者)或者调用远程服务(如果是自己写的HystrixCommand，那么就是重写HystrixCommand的run里面的去调用远程服务的结果)，在这同一次请求第一次的结果会被缓存，保证同一请求中同样的多次访问返回结果相同
 * 请求缓存不是只写入一次结果就不再变化的，而是每次请求到达Controller的时候，
 * 我们都需要为HystrixRequestContext进行初始化，之前的缓存也就是不存在了，我们是在同一个请求中保证结果相同，
 * 同一次请求中的第一次访问后对结果进行缓存，缓存的生命周期只有一次请求！
减轻高并发环境下系统的压力 java中有许多非常好用的缓存工具，比如Redis、EHCache等
判断这个请求是否和之前执行过的请求一样，如果一样，则直接使用缓存数据而不去请求服务提供者
实现方式：
1、通过方法重载开启缓存
如果我们使用了自定义Hystrix请求命令的方式来使用Hystrix，那么我们只需要重写run和getCacheKey方法即可实现请求缓存
#2、通过注解开启缓存
当然，我们也可以通过注解来开启缓存，和缓存相关的注解一共有三个，分别是@CacheResult、@CacheKey和@CacheRemove
#如果使用注解的话，将注解加载本工厂中，调用其他服务的service接口上;那么同一个请求中，调用多次带有改注解的接口第一次的结果会被缓存，其余的会从缓存里拿


# 请求合并
#利弊：
# * 使用请求合并，由于需要把请求进行合并处理，因此会对返回的结果有一定的延迟影响，因此推荐将延迟本身就比较高的请求合并，而不是对延时很低的请求来合并处理。
# * 通过请求合并，系统可以使用比较少的线程资源，因此可以提高整个系统的吞吐量以及减少网络上的资源开销
Hystrix支持两种请求合并的方法
#//Scope.GLOBAL; 所有线程的请求中的多次服务请求进行合并
#//默认，Scope.REQUEST; 对一次请求的多次服务调用合并			
在微服务中，我们将一个项目拆成很多个独立的模块，这些模块相互配合来工作;
但是在高并发的环境下，通信次数增加会导致总的通信时间增加，同时线程资源是有限的，高并发环境会导致大量线程处于等待状态导致响应延迟；
为了解决这些问题histrix有请求合并的功能
1、通过自己实现一个HistrixCommand(这个Commond就是去调用批量处理的请求方法)
2、在自己实现一个HistricCollapser(声明请求时间窗，创建1中的Command实例用该对象去发起一个批量请求)
3、每个请求设置请求结果
4、通过调用自己实现HistricCollapser的实例的queue提交请求和get获取请求结果
当然上面的太烦了
#可以用注解来实现
# @HystrixCollapser在单个请求上加这个注解进行请求合并的处理（声明请求时间窗和batchMethod）【除了使用时间窗大小进行合并的条件，还可以设置请求的个数，默认没设置的时候是无线大的】
# 这里单个请求的service 返回的 Future 包装的对象，如果使用原对象，则是同步请求，不会合并
# 通过这个Future对象get就能拿到值了
# @HystrixCommand声明的方法，表示在请求合并后要通过这个方法进行合并后的请求
# @HystrixCollapser的batchMethod指向上面的HystrixCommand

#服务监控
@EnableHystrixDashboard
浏览器中打开localhost:port/hystrix 
网页中提示数据源有三种： 
http://turbine-hostname:port/turbine.stream （所有集群） 
http://turbine-hostname:port/turbine.stream?cluster=[clusterName]（指定名称的集群） 
http://hystrix-app:port/hystrix.stream（单个应用） 
操作可以看https://blog.csdn.net/qq_36027670/article/details/79872926
如果要能监控所有集群需要集成turbine